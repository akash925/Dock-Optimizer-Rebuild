PROJECT NAME: Dock Optimizer (Rebuild for Hanzo Logistics)

PROJECT DESCRIPTION: We need to build a “Dock Optimizer” application from scratch for Hanzo Logistics. The application should manage inbound/outbound freight scheduling and streamline the assignment of trucks to loading/unloading bays in a warehouse or distribution center environment. We want to replace our existing legacy app with a modern, reliable, and scalable solution. This new system should provide advanced scheduling intelligence, real-time visibility into dock usage, and robust reporting for operational metrics.

KEY OBJECTIVES & FEATURES:

User Management & Roles:

Provide secure user authentication and authorization (e.g., using JSON Web Tokens or session-based).

Support multiple roles such as Admin, Manager, and Dock Worker.

Admins can invite new users and assign roles.

Managers can create and edit dock schedules, track usage, and handle exceptions.

Dock Workers have read-only access to relevant schedules and assigned tasks.

Scheduling & Dock Assignments:

Create, update, and delete dock schedules for inbound and outbound trucks.

Automatically match available docks and timeslots to incoming loads, optimizing for minimal wait times and maximum dock utilization.

Allow for manual overrides when necessary.

Handle standard constraints (trailer lengths, door heights, forklift requirements, etc.).

Real-Time Tracking & Alerts:

Display current dock usage (occupied vs. free) in real time.

Live dashboards for managers and dock workers to see incoming trucks, assigned dock doors, and estimated times.

Automated SMS or email notifications when:

A load is arriving soon.

There is a delay that affects subsequent schedules.

Optional future integration with GPS tracking or ELD data for more accurate ETAs.

Data Storage & Integrations:

Use a modern database (e.g., PostgreSQL, MySQL, or MongoDB) to store:

User and role data

Scheduling records

Historical performance and metrics

Include an ORM layer (like Prisma, SQLAlchemy, or Sequelize) for maintainability.

Provide RESTful (or GraphQL) APIs that external systems can use to integrate with TMS (Transportation Management Systems) or WMS (Warehouse Management Systems).

Analytics & Reporting:

Track KPIs like average truck turnaround time, on-time shipments, dwell time, and door utilization rate.

Generate real-time dashboards and on-demand PDF/CSV reports.

Historical data queries to measure performance over time and identify optimization opportunities.

Scalability & Architecture:

Use a modular architecture that separates the front end, back end, and database layers.

Containerize the application (Docker is preferred) so it can be deployed on any standard cloud service.

Follow 12-Factor App principles for environment configuration.

Front-End Requirements:

Modern single-page application (React, Vue, or Angular) that is responsive and user-friendly.

Interactive dashboards showing dock assignments in a calendar or timeline view.

Form-based workflows for scheduling loads, specifying constraints, and manually adjusting assignments.

Security & Best Practices:

Implement role-based access control (RBAC) and input validation across all APIs.

Use HTTPS for transport security and store credentials with secure hashing/salting.

Prepare for audits/logging to track any changes made to schedules or user access.

Testing & Quality Assurance:

Include unit tests for core scheduling logic, user authentication, and data validations.

Provide integration tests for major workflows (e.g., creating a schedule, assigning a truck, notifying a user).

Automated CI pipeline to run tests, lint code, and build Docker images.

Performance Considerations:

Scheduling engine should be efficient when dealing with large volumes of trucks at once.

Include caching for commonly accessed queries (e.g., dock availability).

Ensure the UI remains performant with a large list of schedules or historical data.

Deployment & Documentation:

Provide a clear README explaining setup, environment variables, and deployment instructions.

Include instructions for local development, staging, and production environments.

Document APIs with Swagger/OpenAPI (if using REST) or an equivalent tool.

EXAMPLE TECH STACK (Feel free to choose the best approach):

Back End: Node.js (Express or NestJS) or Python (FastAPI or Django)

Database: PostgreSQL (SQL) or MongoDB (NoSQL), with an ORM like Prisma/Sequelize/SQLAlchemy

Front End: React (create-react-app or Next.js) or Vue

Containerization: Docker (Dockerfiles + docker-compose) for local dev and eventual CI/CD

Authentication: JWT-based or session-based with Passport.js (Node) or Django’s built-in Auth, etc.

Testing: Jest for front-end/back-end if using JavaScript/TypeScript; Pytest if using Python.

HOW TO IMPLEMENT:

Initialize the Project:

Create a repository with a clean folder structure (e.g., /frontend, /backend, /db).

Set up Dockerfiles and a docker-compose.yml for local development.

Build the Back End:

Scaffold a new Node.js (Express) or Python (FastAPI) service.

Define database models (e.g., “User,” “Schedule,” “Dock,” “Truck,” “Notification”) using an ORM.

Implement the scheduling logic:

Input: list of upcoming trucks, constraints, and dock statuses.

Algorithm: find the optimal time slot/dock combination based on volume and constraints.

Output: confirmed schedule with assigned dock and timeslot.

Set up a notification system (email, SMS, push) to alert relevant parties.

Front-End Implementation:

Use a React-based or Vue-based SPA for user workflows.

Provide a dashboard with a calendar or timeline display of assigned docks.

Show metrics and KPIs in charts (using a library like Chart.js).

Use responsive design so mobile devices and tablets on the warehouse floor can access it.

Testing & Validation:

Include unit tests for the scheduling algorithm, verifying edge cases like:

Multiple trucks arriving at the same time.

High-volume scenarios.

Last-minute schedule changes and overrides.

Create integration tests to ensure end-to-end workflows run smoothly (register new user → schedule a truck → get notifications).

Documentation & Deployment:

Use README and wiki pages to detail the setup steps (environment variables, local Docker usage, environment seeding, etc.).

Provide example .env templates.

Configure CI/CD to build and test the app, then push Docker images to a container registry.

SPECIAL CONSIDERATIONS (FROM PRIOR CONVERSATIONS):

Integrate “dwell time” forecasting to predict how long each truck typically occupies a dock.

Allow managers to manually adjust dwell time assumptions for certain loads (e.g., fragile or large shipments).

Keep an audit trail of all schedule changes (who made the change, timestamp, reason).

Provide the ability to export daily schedules in Excel/CSV so staff can print or share offline if needed.

Use advanced filtering in the UI (e.g., filter by date range, dock door, carrier, or priority).

Enhance reliability for scale: plan for thousands of trucks per day across multiple facilities.

REQUEST: “Replit, please generate all necessary code (front end, back end, and infrastructure) for this new Dock Optimizer application, following the details and best practices outlined above. Make sure the resulting code is well-structured, thoroughly documented, tested, and ready for containerized deployment. Please also suggest improvements, if any, for the scheduling algorithm or the architecture to ensure it can handle large-scale usage at Hanzo Logistics.”

