Objective: Integrate the enhanced `calculateAvailabilitySlots` check into the booking creation endpoints and implement database transactions to ensure data integrity and prevent race conditions.

Context:
- The `calculateAvailabilitySlots` function in `server/src/services/availability.ts` is now considered complete and accurately reflects availability, including break times.
- We need to modify the backend route handlers in `server/src/routes.ts` responsible for creating new appointments. Key endpoints include (but verify if there are others):
    - `POST /api/schedules` (likely for internal/admin bookings)
    - `POST /api/schedules/external` (for external bookings)
    - `POST /api/booking-pages/:slug/book` (for bookings via specific pages)
- The Drizzle ORM `db` instance is available and supports transactions via `await db.transaction(async (tx) => { ... });`.
- The `storage` service instance is available for database operations.

Detailed Task for each relevant booking creation endpoint:

1.  **Parameter Extraction & Preparation:**
    * Inside the route handler, ensure you correctly extract or derive the necessary parameters from `req.body` (or `req.params`) to call `calculateAvailabilitySlots`. This includes:
        * `date`: The date string in "YYYY-MM-DD" format (you might need to derive this from the `startTime` in the request).
        * `facilityId`: The ID of the facility.
        * `appointmentTypeId`: The ID of the appointment type.
        * `requestedStartTimeStr`: The specific time string (e.g., "10:00") the user is trying to book.
    * Determine the `effectiveTenantId` for the operation (similar to how it's done in `/api/availability/v2` for tenant isolation).

2.  **Database Transaction:**
    * Wrap the core logic (availability check and schedule creation) within a Drizzle database transaction:
        ```typescript
        try {
            await db.transaction(async (tx) => {
                // Steps 3 and 4 will go here, using 'tx' if storage methods are adapted
                // For now, storage methods might still use the global 'db' or 'pool'
            });
            // If transaction successful, send success response
        } catch (error) {
            // Handle errors, including specific conflict errors
        }
        ```

3.  **Availability Check (Inside the Transaction Block):**
    * Call the `calculateAvailabilitySlots` function.
        * **Important:** Ideally, `calculateAvailabilitySlots` and its underlying `WorkspaceRelevantAppointmentsForDay` (and any `storage` methods they call) should be refactored to accept the transaction object `tx` as their database handler. If this deep refactoring is too complex for this step, call it with the main `db` instance for now, but acknowledge this is a point for future atomicity improvement. Let's proceed with passing the main `db` for now if `tx` propagation is too complex.
        * Pass the prepared `date`, `facilityId`, `appointmentTypeId`, and `effectiveTenantId`.
    * From the returned `slots` array, find the specific `AvailabilitySlot` object that matches the `requestedStartTimeStr`.
    * If the slot is not found in the results, or if `slot.available` is `false`, or if `slot.remainingCapacity <= 0`, then `throw new Error('SLOT_UNAVAILABLE')`. This custom error type will be caught by the transaction's catch block or the route handler's catch block.

4.  **Create Schedule (Inside the Transaction Block, if availability check passes):**
    * If the availability check passes, proceed with the existing logic to prepare `scheduleData` and call `storage.createSchedule(scheduleData)`.
    * If `storage.createSchedule` can be adapted to use the transaction `tx`, that would be ideal. Otherwise, it will run in its own transaction if it's already designed to do so, or as a separate operation.
    * After successful creation, the transaction will commit.

5.  **Error Handling & Response:**
    * Modify the `catch` block for the route handler.
    * If the caught error's message is `'SLOT_UNAVAILABLE'`, return a `409 Conflict` HTTP status code with a user-friendly message (e.g., "Selected time slot is no longer available or capacity is full. Please try another time.").
    * For other errors (including Zod validation errors if they are handled before the transaction), maintain their existing error handling. General unexpected errors within the transaction should result in a 500.

**Output:**
Provide the updated code for `server/src/routes.ts`, showing the modifications to the identified booking creation endpoints. Highlight the sections where the transaction and the call to `calculateAvailabilitySlots` are added.