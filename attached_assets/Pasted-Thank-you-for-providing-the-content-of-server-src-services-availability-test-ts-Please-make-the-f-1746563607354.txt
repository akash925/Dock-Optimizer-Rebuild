Thank you for providing the content of `server/src/services/availability.test.ts`. Please make the following specific corrections to this test file:

**1. Correct `maxConcurrent` Usage (Schema Alignment):**
   a. In the helper function `createAppointmentType(overrides?: any)`, find the line:
      `maxPerSlot: 2,`
      Replace it with:
      `maxConcurrent: 2, // Use schema-accurate field 'maxConcurrent'`
   b. Search through all test cases (especially within "Concurrency & Capacity" and "Edge Cases") that call `createAppointmentType`. If they pass an override for `maxPerSlot` (e.g., `createAppointmentType({ maxPerSlot: 3 })`), change `maxPerSlot` to `maxConcurrent` (e.g., `createAppointmentType({ maxConcurrent: 3 })`).
   c. In the same test cases, ensure that any assertions checking `remainingCapacity` correctly use the `maxConcurrent` value set for that test. For example, if a test sets `maxConcurrent: 3` and expects full capacity, the assertion should be `expect(slot.remainingCapacity).toBe(3);`.

**2. Correct Parameters for `WorkspaceRelevantAppointmentsForDay` Mock Assertion:**
   a. Find the test case: `it('enforces tenant isolation when fetching relevant appointments', async () => { ... });`
   b. Within this test, **before** the `expect(fetchRelevantAppointmentsForDay).toHaveBeenCalledWith(...)` line, add the following lines to calculate the correct `dayStart` and `dayEnd` Date objects that `calculateAvailabilitySlots` would pass:
      ```typescript
      // Add these lines for calculating date boundaries for the mock expectation
      const { zonedTimeToUtc } = await import('date-fns-tz');
      const { addDays, parseISO } = await import('date-fns');
      const facilityTimezone = 'America/New_York'; // Assuming this from your createFacility mock
      const dayStartForMock = zonedTimeToUtc(`${wednesday}T00:00:00`, facilityTimezone);
      const nextDateForMock = addDays(parseISO(wednesday), 1);
      const nextDateStrForMock = nextDateForMock.toISOString().split('T')[0];
      const dayEndForMock = zonedTimeToUtc(`${nextDateStrForMock}T00:00:00`, facilityTimezone);
      ```
   c. Modify the `expect(fetchRelevantAppointmentsForDay).toHaveBeenCalledWith(...)` line to use these new Date objects:
      ```typescript
      expect(fetchRelevantAppointmentsForDay).toHaveBeenCalledWith(
        mockDb,
        7,               // facilityId
        dayStartForMock, // Corrected: Date object
        dayEndForMock,   // Corrected: Date object
        5                // effectiveTenantId
      );
      ```

**3. Adjust Break Time Reason Assertion:**
   a. Find the test case: `it('slots overlapping with facility break times remain available if allowAppointmentsThroughBreaks is true', async () => { ... });`
   b. Locate the assertion: `expect(slot.reason).toContain('Spans through break time');`
   c. **Change this assertion.** If an appointment is allowed through a break and is otherwise available (due to capacity), the `reason` field in `calculateAvailabilitySlots` likely remains empty or reflects a previous state (like "" if no capacity issue). Change the expectation to something more accurate, for example:
      `expect(slot.reason).toBe(''); // Or whatever the actual reason is if capacity was met but break was allowed`
      (Verify what `calculateAvailabilitySlots` actually does in this scenario. If no specific "allowed through break" reason is added, an empty string is likely correct if the slot is truly available).

**Output:**
Please provide the **complete and updated content of the `server/src/services/availability.test.ts` file** after applying these three sets of corrections.