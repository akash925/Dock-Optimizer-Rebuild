        mockDb,
        mockStorage,
        wednesday,
        facilityId,
        appointmentTypeId,
        tenantId
      );

      // Check that all slots have the full capacity available
      slots.forEach((slot) => {
        if (slot.available) {
          expect(slot.remainingCapacity).toBe(3);
          expect(slot.remaining).toBe(3); // Legacy property should match
        }
      });
    });

    it("correctly calculates remainingCapacity when some appointments exist but don't fill the slot", async () => {
      // Arrange
      const mockStorage = createMockStorage();
      
      // Set up an open facility
      const facilityId = 7;
      const tenantId = 5;
      const facility = createFacility();
      mockStorage._setFacility(facilityId, tenantId, facility);
      
      // Set up appointment type with maxConcurrent: 3
      const appointmentTypeId = 17;
      const appointmentType = createAppointmentType({
        maxConcurrent: 3
      });
      mockStorage._setAppointmentType(appointmentTypeId, appointmentType);
      
      // Set up a Wednesday date
      const wednesday = "2025-05-07"; // A Wednesday
      
      // Use the test appointments option instead of mocking the fetch function
      const nineAM = new Date(`${wednesday}T09:00:00Z`);
      const oneThirtyPM = new Date(`${wednesday}T13:30:00Z`);
      const testAppointments = [
        createAppointment(nineAM, oneThirtyPM),
      ];
      
      // Act - call the actual function with test appointments
      const slots = await calculateAvailabilitySlots(
        mockDb,
        mockStorage,
        wednesday,
        facilityId,
        appointmentTypeId,
        tenantId,
        { testAppointments } // Pass the test appointments instead of mocking fetch
      );

      // Slots at 9:00 should have capacity 2 (3 max - 1 existing)
      const nineAmSlot = slots.find((s) => s.time === "09:00");
      expect(nineAmSlot).toBeDefined();
      expect(nineAmSlot?.remainingCapacity).toBe(2);
      expect(nineAmSlot?.available).toBe(true);

      // Slots at 8:00 should still have full capacity
      const eightAmSlot = slots.find((s) => s.time === "08:00");
      expect(eightAmSlot).toBeDefined();
      expect(eightAmSlot?.remainingCapacity).toBe(3);
      expect(eightAmSlot?.available).toBe(true);
    });

    it("correctly marks a slot as unavailable and remainingCapacity 0 when maxConcurrent is reached", async () => {
      // Arrange
      const mockStorage = createMockStorage();
      
      // Set up an open facility
      const facilityId = 7;
      const tenantId = 5;
      const facility = createFacility();
      mockStorage._setFacility(facilityId, tenantId, facility);
      
      // Set up appointment type with maxConcurrent: 2
      const appointmentTypeId = 17;
      const appointmentType = createAppointmentType({
        maxConcurrent: 2 // Allow up to 2 concurrent appointments
      });
      mockStorage._setAppointmentType(appointmentTypeId, appointmentType);
      
      // Set up a Wednesday date
      const wednesday = "2025-05-07"; // A Wednesday
      
      // Use the test appointments option instead of mocking the fetch function
      const nineAM = new Date(`${wednesday}T09:00:00Z`);
      const oneThirtyPM = new Date(`${wednesday}T13:30:00Z`);
      const testAppointments = [
        createAppointment(nineAM, oneThirtyPM),
        createAppointment(nineAM, oneThirtyPM),
      ];
      
      // Act - call the actual function with test appointments
      const slots = await calculateAvailabilitySlots(
        mockDb,
        mockStorage,
        wednesday,
        facilityId,
        appointmentTypeId,
        tenantId,
        { testAppointments } // Pass the test appointments instead of mocking fetch
      );

      // Slots at 9:00 should be fully booked
      const nineAmSlot = slots.find((s) => s.time === "09:00");
      expect(nineAmSlot).toBeDefined();
      expect(nineAmSlot?.remainingCapacity).toBe(0);
      expect(nineAmSlot?.available).toBe(false);
      expect(nineAmSlot?.reason).toContain("Slot already booked");

      // Slots at 8:00 should still be available
      const eightAmSlot = slots.find((s) => s.time === "08:00");
      expect(eightAmSlot).toBeDefined();
      expect(eightAmSlot?.remainingCapacity).toBe(2);
      expect(eightAmSlot?.available).toBe(true);
    });
  });

  describe("Appointment Type Rules", () => {
    it("overrideFacilityHours: true results in slots being generated outside standard facility hours", async () => {
      // Arrange
      const mockStorage = createMockStorage();
      
      // Set up an open facility
      const facilityId = 7;
      const tenantId = 5;
      const facility = createFacility();
      mockStorage._setFacility(facilityId, tenantId, facility);
      
      // Set up appointment type with override facility hours
      const appointmentTypeId = 17;
      const appointmentType = createAppointmentType({
        overrideFacilityHours: true, // Override facility hours
        bufferTime: 60 // 1-hour slots
      });
      mockStorage._setAppointmentType(appointmentTypeId, appointmentType);
      
      // Set up a Wednesday date
      const wednesday = "2025-05-07"; // A Wednesday
      
      // Mock no existing appointments
      mockedFetchRelevantAppointmentsForDay.mockResolvedValue([]);
      
      // Act - call the actual function
      const slots = await calculateAvailabilitySlots(
        mockDb,
        mockStorage,
        wednesday,
        facilityId,
        appointmentTypeId,
        tenantId
      );

      // Check for slots outside regular hours (facility normally opens at 8:00)
      const earlySlots = slots.filter((s) => {
        const hourMinute = s.time.split(":").map(Number);
        return hourMinute[0] < 8; // Hours before 8am
      });
      expect(earlySlots.length).toBeGreaterThan(0);

      // Check for slots after closing time (facility normally closes at 17:00)
      const lateSlots = slots.filter((s) => {
        const hourMinute = s.time.split(":").map(Number);
        return hourMinute[0] >= 17; // Hours at or after 5pm
      });
      expect(lateSlots.length).toBeGreaterThan(0);
    });

    it("uses correct slotIntervalMinutes calculation based on appointmentType.bufferTime", async () => {
      // Arrange
      const mockStorage = createMockStorage();
      
      // Set up an open facility
      const facilityId = 7;
      const tenantId = 5;
      const facility = createFacility();
      mockStorage._setFacility(facilityId, tenantId, facility);
      
      // Set up appointment type with 45-minute buffer time
      const appointmentTypeId = 17;
      const appointmentType = createAppointmentType({
        bufferTime: 45, // 45-minute slots
      });
      mockStorage._setAppointmentType(appointmentTypeId, appointmentType);
      
      // Set up a Wednesday date
      const wednesday = "2025-05-07"; // A Wednesday
      
      // Mock no existing appointments
      mockedFetchRelevantAppointmentsForDay.mockResolvedValue([]);
      
      // Act - call the actual function
      const slots = await calculateAvailabilitySlots(
        mockDb,
        mockStorage,
        wednesday,
        facilityId,
        appointmentTypeId,
        tenantId
      );

      // Check that slots are spaced 45 minutes apart
      const slotTimes = slots.map((s) => s.time);

      // Check for specific 45-minute intervals
      expect(slotTimes).toContain("08:00");
      expect(slotTimes).toContain("08:45");
      expect(slotTimes).toContain("09:30");
      expect(slotTimes).toContain("10:15");
    });

    it("uses appointmentType.duration when no bufferTime is specified", async () => {
      // Arrange
      const mockStorage = createMockStorage();
      
      // Set up an open facility
      const facilityId = 7;
      const tenantId = 5;
      const facility = createFacility();
      mockStorage._setFacility(facilityId, tenantId, facility);
      
      // Set up appointment type with no buffer time, using duration instead
      const appointmentTypeId = 17;
      const appointmentType = createAppointmentType({
        bufferTime: 0, // No buffer time
        duration: 60, // 1-hour duration
      });
      mockStorage._setAppointmentType(appointmentTypeId, appointmentType);
      
      // Set up a Wednesday date
      const wednesday = "2025-05-07"; // A Wednesday
      
      // Mock no existing appointments
      mockedFetchRelevantAppointmentsForDay.mockResolvedValue([]);
      
      // Act - call the actual function
      const slots = await calculateAvailabilitySlots(
        mockDb,
        mockStorage,
        wednesday,
        facilityId,
        appointmentTypeId,
        tenantId
      );

      // Check that slots are spaced 60 minutes apart
      const slotTimes = slots.map((s) => s.time);

      // Check for specific 60-minute intervals
      expect(slotTimes).toContain("08:00");
      expect(slotTimes).toContain("09:00");
      expect(slotTimes).toContain("10:00");
      expect(slotTimes).toContain("11:00");
    });
  });

  describe("Break Time Logic", () => {
    it("slots overlapping with facility break times are marked unavailable if allowAppointmentsThroughBreaks is false", async () => {
      // Arrange
      const mockStorage = createMockStorage();
      
      // Set up a facility with a break time from 12-1pm on Wednesdays
      const facilityId = 7;
      const tenantId = 5;
      const facility = createFacility({
        wednesdayBreakStart: "12:00",
        wednesdayBreakEnd: "13:00",
      });
      mockStorage._setFacility(facilityId, tenantId, facility);
      
      // Set up appointment type that does NOT allow booking through breaks
      const appointmentTypeId = 17;
      const appointmentType = createAppointmentType({
        allowAppointmentsThroughBreaks: false,
        bufferTime: 30, // 30-minute slots
      });
      mockStorage._setAppointmentType(appointmentTypeId, appointmentType);
      
      // Set up a Wednesday date
      const wednesday = "2025-05-07"; // A Wednesday
      
      // Mock no existing appointments
      mockedFetchRelevantAppointmentsForDay.mockResolvedValue([]);
      
      // Act - call the actual function
      const slots = await calculateAvailabilitySlots(
        mockDb,
        mockStorage,
        wednesday,
        facilityId,
        appointmentTypeId,
        tenantId
      );

      // Check that slots during break time are marked as unavailable
      const breakTimeSlots = slots.filter(
        (s) => s.time === "12:00" || s.time === "12:30",
