import express, { Request, Response, NextFunction } from "express";
import { getStorage } from "../../../storage";
import { db } from "../../../db";
import { eq, sql } from "drizzle-orm";
import { users, organizationUsers, roles } from "@shared/schema";
import { tenants as organizations } from "@shared/schema";

const router = express.Router();

// Middleware to check if user is a super-admin
const requireSuperAdmin = (req: Request, res: Response, next: NextFunction) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ message: "Unauthorized" });
  }

  if (req.user?.role !== "super-admin") {
    return res.status(403).json({ message: "Access denied. Super admin role required." });
  }

  next();
};

router.use(requireSuperAdmin);

// GET /admin/users - Get all users with their roles across organizations (with pagination)
router.get("/", async (req: Request, res: Response) => {
  try {
    // Parse pagination parameters
    const page = Number(req.query.page) || 1;
    const limit = Number(req.query.limit) || 20;
    const offset = (page - 1) * limit;
    
    // Get total count for pagination
    const totalUsers = await db.select({ count: sql`count(*)` }).from(users);
    const total = Number(totalUsers[0]?.count || 0);
    
    // Use a more efficient SQL query to get users with their memberships in one go
    const query = sql`
      SELECT 
        u.id, u.email, u.username, u.first_name AS "firstName", u.last_name AS "lastName",
        COALESCE(
          json_agg(
            json_build_object(
              'orgId', ou.organization_id,
              'orgName', t.name,
              'roleName', r.name
            ) 
          ) FILTER (WHERE ou.organization_id IS NOT NULL), 
          '[]'
        ) AS memberships
      FROM users u
      LEFT JOIN organization_users ou ON ou.user_id = u.id
      LEFT JOIN tenants t ON t.id = ou.organization_id
      LEFT JOIN roles r ON r.id = ou.role_id
      GROUP BY u.id
      ORDER BY u.id
      LIMIT ${limit} OFFSET ${offset}
    `;
    
    const usersWithMemberships = await db.execute(query);
    
    // Return the results with pagination info
    res.json({
      items: usersWithMemberships,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    });
            orgId: organizations.id,
            orgName: organizations.name,
            roleId: organizationUsers.roleId,
            roleName: roles.name,
          })
          .from(organizationUsers)
          .innerJoin(organizations, eq(organizationUsers.organizationId, organizations.id))
          .innerJoin(roles, eq(organizationUsers.roleId, roles.id))
          .where(eq(organizationUsers.userId, user.id));

        return {
          userId: user.id,
          email: user.email,
          username: user.username,
          firstName: user.firstName,
          lastName: user.lastName,
          roles: userOrgs.map(org => ({
            orgId: org.orgId,
            orgName: org.orgName,
            roleName: org.roleName
          }))
        };
      })
    );

    res.json({
      items: usersWithRoles,
      pagination: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit)
      }
    });
  } catch (error: unknown) {
    console.error("Error fetching users:", error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    res.status(500).json({ message: "Failed to fetch users", error: errorMessage });
  }
});

// GET /admin/users/:userId - Get detailed user information
router.get("/:userId", async (req: Request, res: Response) => {
  try {
    const userId = Number(req.params.userId);
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }

    // Get the user
    const [user] = await db
      .select({
        id: users.id,
        username: users.username,
        email: users.email,
        firstName: users.firstName,
        lastName: users.lastName,
      })
      .from(users)
      .where(eq(users.id, userId));

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    // Get all organization roles for this user
    const userOrgs = await db
      .select({
        orgId: organizations.id,
        orgName: organizations.name,
        roleId: organizationUsers.roleId,
        roleName: roles.name,
      })
      .from(organizationUsers)
      .innerJoin(organizations, eq(organizationUsers.organizationId, organizations.id))
      .innerJoin(roles, eq(organizationUsers.roleId, roles.id))
      .where(eq(organizationUsers.userId, userId));

    // Get activity logs for this user (placeholder - you'll need to create this table)
    // This is simplified for now - you'd typically have a proper activity_logs table
    const activityLogs = []; // Will implement later

    const userDetail = {
      ...user,
      roles: userOrgs.map(org => ({
        orgId: org.orgId,
        orgName: org.orgName,
        roleId: org.roleId,
        roleName: org.roleName
      })),
      activityLogs
    };

    res.json(userDetail);
  } catch (error: unknown) {
    console.error("Error fetching user details:", error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    res.status(500).json({ message: "Failed to fetch user details", error: errorMessage });
  }
});

// PUT /admin/users/:userId/orgs - Add or remove user from an organization
router.put("/:userId/orgs", async (req: Request, res: Response) => {
  try {
    const userId = Number(req.params.userId);
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }

    const { orgId, roleId, action } = req.body;

    // Validate request body
    if (!orgId || (action === "add" && !roleId) || !["add", "remove"].includes(action)) {
      return res.status(400).json({ 
        message: "Invalid request. Must include orgId, roleId (for add), and action ('add' or 'remove')" 
      });
    }

    // Check if user exists
    const [userExists] = await db
      .select({ id: users.id })
      .from(users)
      .where(eq(users.id, userId));

    if (!userExists) {
      return res.status(404).json({ message: "User not found" });
    }

    // Check if organization exists
    const [orgExists] = await db
      .select({ id: organizations.id })
      .from(organizations)
      .where(eq(organizations.id, orgId));

    if (!orgExists) {
      return res.status(404).json({ message: "Organization not found" });
    }

    // If action is "add", check if role exists
    if (action === "add" && roleId) {
      const [roleExists] = await db
        .select({ id: roles.id })
        .from(roles)
        .where(eq(roles.id, roleId));

      if (!roleExists) {
        return res.status(404).json({ message: "Role not found" });
      }
    }

    const storage = await getStorage();

    if (action === "add") {
      // Check if the user is already in the organization
      const existingUserOrg = await storage.getUserOrganizationRole(userId, orgId);
      
      if (existingUserOrg) {
        return res.status(400).json({ message: "User is already assigned to this organization" });
      }

      // Add user to organization
      const result = await storage.addUserToOrganization({
        userId,
        organizationId: orgId,
        roleId
      });

      return res.status(200).json({
        message: "User added to organization successfully",
        data: result
      });
    } else { // action === "remove"
      // Check if the user is in the organization
      const existingUserOrg = await storage.getUserOrganizationRole(userId, orgId);
      
      if (!existingUserOrg) {
        return res.status(400).json({ message: "User is not assigned to this organization" });
      }

      // Don't allow removing the last super-admin from the admin organization
      if (orgId === 1) { // Assuming 1 is the admin org ID
        const [org] = await db
          .select()
          .from(organizations)
          .where(eq(organizations.id, orgId));
          
        if (org.subdomain === 'admin') {
          const role = await storage.getRole(existingUserOrg.roleId);
          if (role && role.name === 'super-admin') {
            const adminOrgUsers = await storage.getOrganizationUsers(orgId);
            const superAdminCount = await Promise.all(adminOrgUsers.map(async (ou) => {
              const r = await storage.getRole(ou.roleId);
              return r && r.name === 'super-admin' ? 1 : 0;
            })).then(counts => counts.reduce((sum, count) => sum + count, 0));
            
            if (superAdminCount <= 1) {
              return res.status(403).json({ 
                message: 'Cannot remove the last super-admin from the system' 
              });
            }
          }
        }
      }

      // Remove user from organization
      await storage.removeUserFromOrganization(userId, orgId);

      return res.status(200).json({
        message: "User removed from organization successfully"
      });
    }
  } catch (error: unknown) {
    console.error("Error managing user organization:", error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    res.status(500).json({ message: "Failed to update user organization", error: errorMessage });
  }
});

// GET /admin/users/:userId/logs - Get activity logs for a user (optional)
router.get("/:userId/logs", async (req: Request, res: Response) => {
  try {
    const userId = Number(req.params.userId);
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }

    // Check if user exists
    const [userExists] = await db
      .select({ id: users.id })
      .from(users)
      .where(eq(users.id, userId));

    if (!userExists) {
      return res.status(404).json({ message: "User not found" });
    }

    // This is a placeholder - in a real implementation, you'd query your activity_logs table
    // You can implement pagination with limit/offset here
    const activityLogs = [
      {
        id: 1,
        timestamp: new Date().toISOString(),
        action: "account_login",
        details: "User logged in successfully",
      }
    ];

    res.json({ 
      data: activityLogs,
      pagination: {
        total: 1,
        page: 1,
        limit: 10
      } 
    });
  } catch (error: unknown) {
    console.error("Error fetching user logs:", error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    res.status(500).json({ message: "Failed to fetch user logs", error: errorMessage });
  }
});

export default router;