// Import Vitest testing utilities
import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";

// Import storage interface
import { IStorage } from "../../storage";
// Import timezone utilities
import { toZonedTime, format as tzFormat } from "date-fns-tz";
// Import date-fns utilities
import { addDays, parseISO, format, getDay } from "date-fns";

// Define a replacement for the zonedTimeToUtc function that's not in date-fns-tz v3.2.0
function zonedTimeToUtc(dateString: string, timeZone: string): Date {
  // Parse the string to a date object using the specified timezone
  const zonedDate = toZonedTime(parseISO(dateString), timeZone);
  // Return as UTC date
  return new Date(zonedDate);
}

// Create a fully mocked version of fetchRelevantAppointmentsForDay that won't use Drizzle's query builder
const mockedFetchRelevantAppointmentsForDay = vi.fn().mockResolvedValue([]);

// First set up the mocks
vi.mock('./availability', async () => {
  const actualModule = await vi.importActual('./availability');
  
  return {
    ...actualModule,
    // Override the function with the standalone mock that doesn't rely on database objects
    fetchRelevantAppointmentsForDay: async (db: any, facilityId: number, date: string, effectiveTenantId: number) => {
      // Pass the arguments to our mock to track calls
      mockedFetchRelevantAppointmentsForDay(db, facilityId, date, effectiveTenantId);
      // Return the mock value
      return await mockedFetchRelevantAppointmentsForDay();
    }
  };
});

// Import the functions after mocking
import { calculateAvailabilitySlots } from './availability';

// We don't need to import the mocked function since we've already created it above

// Mock dependencies with a more complete Drizzle-like query chain
const mockDb = {
  select: vi.fn().mockReturnThis(),
  from: vi.fn().mockReturnThis(),
  leftJoin: vi.fn().mockReturnThis(),
  where: vi.fn().mockReturnThis(),
  orderBy: vi.fn().mockReturnThis(),
  execute: vi.fn().mockResolvedValue([]),
  prepare: vi.fn().mockReturnThis(),
  all: vi.fn().mockResolvedValue([]),
  get: vi.fn().mockResolvedValue(null),
  values: vi.fn().mockReturnThis(),
  onConflictDoNothing: vi.fn().mockReturnThis(),
  onConflictDoUpdate: vi.fn().mockReturnThis(),
  returning: vi.fn().mockResolvedValue([]),
  $transaction: vi.fn().mockImplementation((cb) => cb(mockDb))
};

// Create a reusable test fixture with a mock storage
function createMockStorage(): IStorage {
  const facilitiesMap = new Map();
  const appointmentTypesMap = new Map();
  const docksMap = new Map();
  const schedules = [];
  
  return {
    // Mock any IStorage methods needed by the test
    getFacility: vi.fn().mockImplementation((facilityId, tenantId) => {
      const key = `${facilityId}_${tenantId || 'any'}`;
      return Promise.resolve(facilitiesMap.get(key));
    }),
    
    getAppointmentType: vi.fn().mockImplementation((appointmentTypeId) => {
      return Promise.resolve(appointmentTypesMap.get(appointmentTypeId));
    }),
    
    // Helper methods to set up test data
    _setFacility: (facilityId, tenantId, facility) => {
      const key = `${facilityId}_${tenantId || 'any'}`;
      facilitiesMap.set(key, facility);
    },
    
    _setAppointmentType: (appointmentTypeId, appointmentType) => {
      appointmentTypesMap.set(appointmentTypeId, appointmentType);
    },
    
    // Add any other required methods from IStorage interface with mock implementations
    getUserFacilities: vi.fn().mockResolvedValue([]),
    getUserStores: vi.fn().mockResolvedValue([]),
    getUser: vi.fn().mockResolvedValue(null),
    // Include other required methods with minimal implementations
  };
}

// Mock data generators
function createFacility(overrides?: any) {
  return {
    id: 7,
    name: "Test Facility",
    timezone: "America/New_York",
    // Default to being open Monday-Friday 8am-5pm
    sundayOpen: false,
    sundayStart: null,
    sundayEnd: null,
    sundayBreakStart: null,
    sundayBreakEnd: null,

    mondayOpen: true,
    mondayStart: "08:00",
    mondayEnd: "17:00",
    mondayBreakStart: "12:00",
    mondayBreakEnd: "13:00",

    tuesdayOpen: true,
    tuesdayStart: "08:00",
    tuesdayEnd: "17:00",
    tuesdayBreakStart: "12:00",
    tuesdayBreakEnd: "13:00",

    wednesdayOpen: true,
    wednesdayStart: "08:00",
    wednesdayEnd: "17:00",
    wednesdayBreakStart: "12:00",
    wednesdayBreakEnd: "13:00",

    thursdayOpen: true,
    thursdayStart: "08:00",
    thursdayEnd: "17:00",
    thursdayBreakStart: "12:00",
    thursdayBreakEnd: "13:00",

    fridayOpen: true,
    fridayStart: "08:00",
    fridayEnd: "17:00",
    fridayBreakStart: "12:00",
    fridayBreakEnd: "13:00",

    saturdayOpen: false,
    saturdayStart: null,
    saturdayEnd: null,
    saturdayBreakStart: null,
    saturdayBreakEnd: null,

    ...overrides,
  };
}

function createAppointmentType(overrides?: any) {
  return {
    id: 17,
    name: "4 Hour Container Appointment",
    duration: 240, // 4 hours in minutes
    bufferTime: 30,
    maxConcurrent: 2, // Use schema-accurate field 'maxConcurrent'
    tenantId: 5,
    allowAppointmentsThroughBreaks: false,
    overrideFacilityHours: false,
    ...overrides,
  };
}

function createAppointment(startTime: Date, endTime: Date) {
  return {
    id: Math.floor(Math.random() * 1000),
    startTime,
    endTime,
  };
}

// Note: We already imported what we need from "./availability" above

describe("calculateAvailabilitySlots", () => {
  beforeEach(() => {
    // Reset all mocks before each test
    vi.clearAllMocks();
  });

  afterEach(() => {
    // Clear mocks after each test
    vi.clearAllMocks();
  });
  
  // We're already using the actual implementation for tests

  describe("Basic Functionality", () => {
    it("returns empty slots if the facility is marked as closed for the day", async () => {
      // Arrange
      const mockStorage = createMockStorage();
      
      // Set up a closed facility
      const facilityId = 7;
      const tenantId = 5;
      const facility = createFacility({ sundayOpen: false });
      mockStorage._setFacility(facilityId, tenantId, facility);
      
      // Set up appointment type
      const appointmentTypeId = 17;
      const appointmentType = createAppointmentType();
      mockStorage._setAppointmentType(appointmentTypeId, appointmentType);
      
      // Set up a Sunday date
      const sunday = "2025-05-11"; // A Sunday
      
      // Act - call the function
      const slots = await calculateAvailabilitySlots(
        mockDb,
        mockStorage,
        sunday,
        facilityId,
        appointmentTypeId,
        tenantId
      );

      // Assert
      expect(slots).toEqual([]);
      expect(mockStorage.getFacility).toHaveBeenCalledWith(7, 5);
      expect(mockStorage.getAppointmentType).toHaveBeenCalledWith(17);
    });

    it("returns correctly generated slots based on facility operating hours and slotIntervalMinutes", async () => {
      // Arrange
      const mockStorage = createMockStorage();
      
      // Set up an open facility
      const facilityId = 7;
      const tenantId = 5;
      const facility = createFacility();
      mockStorage._setFacility(facilityId, tenantId, facility);
      
      // Set up appointment type with 30-min buffer
      const appointmentTypeId = 17;
      const appointmentType = createAppointmentType({
        bufferTime: 30, // 30-minute slots
      });
      mockStorage._setAppointmentType(appointmentTypeId, appointmentType);
      
      // Set up a Wednesday date
      const wednesday = "2025-05-07"; // A Wednesday
      
      // Mock no existing appointments
      mockedFetchRelevantAppointmentsForDay.mockResolvedValue([]);
      
      // Act
      const slots = await calculateAvailabilitySlots(
        mockDb,
        mockStorage,
        wednesday,
        facilityId,
        appointmentTypeId,
        tenantId
      );

      // Check that we have the expected number of slots (18 slots for 8am-5pm with 30-min intervals)
      // But exclude 12:00-13:00 which is break time (2 slots)
      // So we should have 16 valid slots
      expect(slots.length).toBeGreaterThan(0);

      // Check first slot is at 8:00
      expect(slots[0].time).toBe("08:00");

      // Check last slot should be the last valid time before 5:00 (16:30)
      expect(slots[slots.length - 1].time).toBe("16:30");

      // Check slot interval (30 minutes)
      const slotTimes = slots.map((s) => s.time);
      expect(slotTimes).toContain("08:00");
      expect(slotTimes).toContain("08:30");
      expect(slotTimes).toContain("09:00");
    });
  });

  describe("Concurrency & Capacity", () => {
    it("correctly calculates remainingCapacity when no appointments exist", async () => {
      // Arrange
      const mockStorage = createMockStorage();
      
      // Set up an open facility
      const facilityId = 7;
      const tenantId = 5;
      const facility = createFacility();
      mockStorage._setFacility(facilityId, tenantId, facility);
      
      // Set up appointment type with maxConcurrent: 3
      const appointmentTypeId = 17;
      const appointmentType = createAppointmentType({
        maxConcurrent: 3, // Allow up to 3 concurrent appointments
      });
      mockStorage._setAppointmentType(appointmentTypeId, appointmentType);
      
      // Set up a Wednesday date
      const wednesday = "2025-05-07"; // A Wednesday
      
      // Mock no existing appointments
      mockedFetchRelevantAppointmentsForDay.mockResolvedValue([]);
      
      // Act - call the actual function
      const slots = await calculateAvailabilitySlots(
        mockDb,
